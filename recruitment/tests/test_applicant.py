import pytest
from PIL import Image
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from django.core.files.uploadedfile import SimpleUploadedFile
from rest_framework import status
from model_bakery import baker

from conftest import JWT, USER_TOKEN, USERS_ENDPOINT, user_payload
from recruitment.models import Applicant, ApplicantDocument


APPLICANT_ENDPOINT = '/recruitment/applicants/'


def create_image_file():
    # Create a new blank image with size 100x100
    image = Image.new('RGB', (100, 100))

    # Create a temporary file in memory to save the image
    tmp_file = BytesIO()
    image.save(tmp_file, 'PNG')
    # Move the pointer at the begining of the file for the entire data to be read.
    tmp_file.seek(0)

    # Create a Django SimpleUploadedFile object from the temporary file
    uploaded_file = SimpleUploadedFile(
        'test_image.png', tmp_file.read(), content_type='image/png')

    return uploaded_file


@pytest.mark.django_db
class TestApplicant:
    """
    THIS TEST WILL FIAIL WHEN I APPLY PERMISSIONS WHICH I'LL DO LATER!
    Applicant has OneToOne relationship with User. 
    All views require authentication by REST_FRAMEWORK DEFAULT_PERMISSION_CLASSES SETTING.

    If you don't want field validation use Model Baker else add the fields manually.
    baker.make(User, email='mecom') Baker considers the email as valid.

    The serializer that was used to post is that same serializer 
    that is use to return the response. Get request serializer only use for get request
    """

    def payload(self):
        """
        Without the use of baker.make I'll have to manually provide the value
        for application_date which is a related model in Applicant model. It is 
        a mandatory field but its value is automated in Applicant save method. 
        """
        data = baker.make(Applicant)
        return {
            'religion': data.religion,
            'image': create_image_file(),
            'gender': data.gender,
            'birth_date': data.birth_date,
            'county': data.county
        }

    def test_if_authenticated_user_can_post_applicant_return_201(self, post, api_client):
        """ See this class for the comment"""
        user_resp = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.payload())
        instance = Applicant.objects.get(user_id=user_resp.data['id'])

        assert response.status_code == status.HTTP_201_CREATED
        assert instance.user.id == user_resp.data['id']

    def test_if_anonymous_user_cannot_post_applicant_return_401(self, post):
        """ See this class for the comment"""
        user_resp = post(USERS_ENDPOINT, user_payload())
        response = post(APPLICANT_ENDPOINT, self.payload())

        assert user_resp.data['id'] > 0
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_authenticated_user_can_get_applicant_return_200(self, post, get, api_client):
        """ See this class for the comment"""
        user_resp = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.payload())
        response = get(APPLICANT_ENDPOINT, user_resp.data['id'])

        assert response.status_code == status.HTTP_200_OK
        assert response.data['user']['id'] == user_resp.data['id']

    def test_if_authenticated_user_can_get_all_applicants_return_200(self, post, api_client, get_all):
        """ Although any authenticated user can get all applicants
            which is not good. Leter I'll apply permission to the 
            Applicant view and create another Applicant view call
            ApplicantProfile which will only allow applicant to get
            only thier relevant data and allow only PATCH request.
        """
        post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.payload())
        response = get_all(APPLICANT_ENDPOINT)

        assert response.status_code == status.HTTP_200_OK

    def test_if_authenticated_user_can_patch_applicant_return_200(self, post, patch, api_client):
        """ Put request will fial if you don't give all the fields which is only unique here.
            Perhaps it's becasue of the file field [image] in the model.
            Id number should never be updated, but I'm using it because 
            it's not generated by model bakery.
        """
        data = {'id_number': '099', 'image': create_image_file()}

        user_res = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.payload())
        response = patch(APPLICANT_ENDPOINT, user_res.data['id'], data)

        assert response.status_code == status.HTTP_200_OK
        assert response.data['id_number'] == '099'

    def test_if_authenticated_user_can_delete_applicant_return_204(self, post, delete, api_client):
        """ See the this class for comment """
        user_res = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.payload())
        response = delete(APPLICANT_ENDPOINT, user_res.data['id'])

        assert response.status_code == status.HTTP_204_NO_CONTENT

    # def test_if_partial_permission_user_cannot_update_applicationdate_return_403(self, post, update, group_instance):
    #     post_resp = post(APPLICANT_ENDPOINT,
    #                      self.applicationdate_payload())
    #     excluded_permission = Permission.objects.filter(
    #         name__in=['Can change application date'])
    #     group_instance.permissions.remove(*excluded_permission)
    #     response = update(APPLICANT_ENDPOINT,
    #                       post_resp.data['id'], self.applicationdate_payload(open_date='2025-12-15'))

    #     assert response.status_code == status.HTTP_403_FORBIDDEN
    #     assert post_resp.data['open_date'] != '2025-12-15'
    #     assert post_resp.data['open_date'] == '2024-04-15'

    # def test_if_partial_permission_user_cannot_delete_applicationdate_return_403(self, post, delete, group_instance):
    #     post_resp = post(APPLICANT_ENDPOINT,
    #                      self.applicationdate_payload())
    #     excluded_permission = Permission.objects.filter(
    #         name__in=['Can delete application date'])
    #     group_instance.permissions.remove(*excluded_permission)
    #     response = delete(APPLICANT_ENDPOINT, post_resp.data['id'])

    #     assert response.status_code == status.HTTP_403_FORBIDDEN
    #     assert post_resp.data['id'] > 0

    # def test_if_permissionless_user_cannot_post_applicationdate_return_403(self, post, group_instance):
    #     """
    #     Because they cannot post means they can't get, update or delete the resource.
    #     """
    #     excluded_permission = Permission.objects.filter(
    #         name__in=['Can add application date'])
    #     group_instance.permissions.remove(*excluded_permission)

    #     data = self.applicationdate_payload()
    #     response = post(APPLICANT_ENDPOINT, data)

    #     assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_return_400(self, post, api_client):
        """ Although this test will fail if the data is valid; however,
            instead of returning 'assert 201 == 400' error, it will 
            return a misleading error message about ApplicationDate.
        """
        data = {
            'religion': '',
            'image': create_image_file(),
            'gender': 'Male',
            'birth_date': '2004-03-23',
            'county': 'Bong'
        }

        post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, data)

        assert response.status_code == status.HTTP_400_BAD_REQUEST


# ------------------------ ApplicantDocument ---------------

APP_DOCUMENT_ENDPOINT = '/recruitment/applicant-documents/'


def create_pdf_file():
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    c.drawString(100, 750, "Hello, this is a test PDF file!")
    c.save()
    buffer.seek(0)
    return buffer


@pytest.mark.skip
@pytest.mark.django_db
class TestApplicantDocument:
    """ 
    If you don't want field validation use Model Baker else add the fields manually.
    baker.make(User, email='mecom') Baker considers the email as valid.
    """

    def document_payload(self):
        from core.models import User
        data = baker.make(ApplicantDocument)
        user = baker.make(User)
        return {
            'institution': data.institution,
            'major': data.manor,
            'manor': data.manor,
            'graduation_year': data.graduation_year,
            'qualification': data.qualification,
            'county': data.county,
            'country': data.country,
            'cgpa': data.cgpa,
            'degree': create_pdf_file(),
            'police_clearance': create_pdf_file(),
            'resume': create_pdf_file(),
            'community_letter': create_pdf_file(),
            'reference_letter': create_pdf_file(),
            'application_letter': create_pdf_file(),
        }
        # return {
        #     'institution': 'Doriam University',
        #     'major': 'Math',
        #     'manor': 'Physics',
        #     'graduation_year': 2020,
        #     'qualification': 'Bachelor',
        #     'county': 'Bong',
        #     'country': 'Liberia',
        #     'cgpa': 3.8,
        #     'degree': create_pdf_file(),
        #     'police_clearance': create_pdf_file(),
        #     'resume': create_pdf_file(),
        #     'community_letter': create_pdf_file(),
        #     'reference_letter': create_pdf_file(),
        #     'application_letter': create_pdf_file(),
        # }

    def applicant_payload(self):
        """
        Without the use of baker.make I'll have to manually provide the value
        for application_date which is a related model in Applicant model. It is 
        a mandatory field but its value is automated in Applicant save method. 
        """
        data = baker.make(Applicant)
        return {
            'religion': data.religion,
            'image': create_image_file(),
            'gender': data.gender,
            'birth_date': data.birth_date,
            'county': data.county
        }

    def test_if_authenticated_user_can_post_document_return_201(self, post, api_client):
        """ See this class for the comment"""
        # applicant = TestApplicant()
        # app_payload = applicant.applicant_payload()
        # print('********* APPLICANT DICT ', app_payload)

        user_resp = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        applicant_res = post(APPLICANT_ENDPOINT, self.applicant_payload())
        # print('********* APPLICANT RESPONSE ', applicant_res.data)
        applicant = Applicant.objects.get(user_id=user_resp.data['id'])
        # data = self.document_payload()['applicant_id'] = applicant_res.data['user_id'] # the ApplicantSerializer fields for creation does not include user and it is using that same serializer to return a response although there is a serializer for get request. So it raises KeyError user_id
        # Replace the document_payload with applicant.user.id
        data = self.document_payload()['applicant_id'] = applicant.user.id
        # data = self.document_payload().update({'applicant_id': applicant.user.id}) ##Give error related to FormData
        print('********* DOCUMENT DATA ',
              self.document_payload().update({'applicant_id': user_resp.data['id']}))
        # In DocumentVieSet I got the user_id from the request obj so this test is of user_id when posting Document and user_id is not in the serializer so I can't add it to document_payload. I'm testing Address since its applicant_id is in the serializer. I will come back here when done.
        response = post(APP_DOCUMENT_ENDPOINT, self.document_payload())

        document = ApplicantDocument.objects.get(
            applicant_id=applicant_res.data['user_id'])

        assert response.status_code == status.HTTP_201_CREATED
        # assert document.applicant.id == applicant_res.data['user_id']


# ---------------------- ApplicantAddress -------------------
APP_ADDRESS_ENDPOINT = '/recruitment/applicant-address/'


@pytest.mark.skip
@pytest.mark.django_db
class TestApplicantAddress:
    """ ApplicantDocument has OneToOne relationship to Applicant 
        The serializer that was used to post is that same serializer 
        that is use to return the response. Get request serializer only use for get request
    """

    def payload(self):
        """ Country default value is Liberia that's it's not included """
        return {
            'applicant': 1,
            'county': 'Bong',
            'district': 1,
            'community': 'A',
            'house_address': 'ABC'
        }

    def test_create_address(self, post, api_client):
        """ 
        If you instantiate TestApplicant here all of its tests will run
        thus causing unique constraint error for 1-1 relationship when 
        you attempt to post to that same endpoint with the same payload.
        But when instantiated in a request method it is use as value not TestClass. 

        See this class for generic comment
        """
        user_resp = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        post(APPLICANT_ENDPOINT, TestApplicant().payload())
        applicant = Applicant.objects.get(user_id=user_resp.data['id'])
        response = post(APP_ADDRESS_ENDPOINT, self.payload())

        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['applicant'] == applicant.user.id
