import pytest
from PIL import Image
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from django.core.files.uploadedfile import SimpleUploadedFile
from rest_framework import status
from model_bakery import baker

from conftest import JWT, USER_TOKEN, USERS_ENDPOINT, user_payload
from recruitment.models import Applicant


APPLICANT_ENDPOINT = '/recruitment/applicants/'


def create_image_file():
    # Create a new blank image with size 100x100
    image = Image.new('RGB', (100, 100))

    # Create a temporary file in memory to save the image
    tmp_file = BytesIO()
    image.save(tmp_file, 'PNG')
    # Move the pointer at the begining of the file for the entire data to be read.
    tmp_file.seek(0)

    # Create a Django SimpleUploadedFile object from the temporary file
    uploaded_file = SimpleUploadedFile(
        'test_image.png', tmp_file.read(), content_type='image/png')

    return uploaded_file


@pytest.mark.django_db
class TestApplicant:
    """
    THIS TEST WILL FIAIL WHEN I APPLY PERMISSIONS WHICH I'LL DO LATER!
    Applicant has OneToOne relationship with User. 
    All views require authentication by REST_FRAMEWORK DEFAULT_PERMISSION_CLASSES SETTING.
    If you don't want field validation use Model Baker else add the fields manually.
    baker.make(User, email='mecom') Baker considers the email as valid.
    """

    def applicant_payload(self):
        """
        Without the use of baker.make I'll have to manually provide the value
        for application_date which is a related model in Applicant model. It is 
        a mandatory field but its value is automated in Applicant save method. 
        """
        data = baker.make(Applicant)
        return {
            'religion': data.religion,
            'image': create_image_file(),
            'gender': data.gender,
            'birth_date': data.birth_date,
            'county': data.county
        }

    def test_if_authenticated_user_can_post_applicant_return_201(self, post, api_client):
        """ See this class for the comment"""
        user_resp = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.applicant_payload())
        instance = Applicant.objects.get(user_id=user_resp.data['id'])

        assert response.status_code == status.HTTP_201_CREATED
        assert instance.user.id == user_resp.data['id']

    def test_if_anonymous_user_cannot_post_applicant_return_401(self, post):
        """ See this class for the comment"""
        user_resp = post(USERS_ENDPOINT, user_payload())
        response = post(APPLICANT_ENDPOINT, self.applicant_payload())

        assert user_resp.data['id'] > 0
        assert response.status_code == status.HTTP_401_UNAUTHORIZED

    def test_if_authenticated_user_can_get_applicant_return_200(self, post, get, api_client):
        """ See this class for the comment"""
        user_resp = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.applicant_payload())
        response = get(APPLICANT_ENDPOINT, user_resp.data['id'])

        assert response.status_code == status.HTTP_200_OK
        assert response.data['user']['id'] == user_resp.data['id']

    def test_if_authenticated_user_can_get_all_applicants_return_200(self, post, api_client, get_all):
        """ Although any authenticated user can get all applicants
            which is not good. Leter I'll apply permission to the 
            Applicant view and create another Applicant view call
            ApplicantProfile which will only allow applicant to get
            only thier relevant data and allow only PATCH request.
        """
        post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.applicant_payload())
        response = get_all(APPLICANT_ENDPOINT)

        assert response.status_code == status.HTTP_200_OK

    def test_if_authenticated_user_can_patch_applicant_return_200(self, post, patch, api_client):
        """ Put request will fial if you don't give all the fields which is only unique here.
            Perhaps it's becasue of the file field [image] in the model.
            Id number should never be updated, but I'm using it because 
            it's not generated by model bakery.
        """
        data = {'id_number': '099', 'image': create_image_file()}

        user_res = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.applicant_payload())
        response = patch(APPLICANT_ENDPOINT, user_res.data['id'], data)

        assert response.status_code == status.HTTP_200_OK
        assert response.data['id_number'] == '099'

    def test_if_authenticated_user_can_delete_applicant_return_204(self, post, delete, api_client):
        """ See the this class for comment """
        user_res = post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, self.applicant_payload())
        response = delete(APPLICANT_ENDPOINT, user_res.data['id'])

        assert response.status_code == status.HTTP_204_NO_CONTENT

    # def test_if_partial_permission_user_cannot_update_applicationdate_return_403(self, post, update, group_instance):
    #     post_resp = post(APPLICANT_ENDPOINT,
    #                      self.applicationdate_payload())
    #     excluded_permission = Permission.objects.filter(
    #         name__in=['Can change application date'])
    #     group_instance.permissions.remove(*excluded_permission)
    #     response = update(APPLICANT_ENDPOINT,
    #                       post_resp.data['id'], self.applicationdate_payload(open_date='2025-12-15'))

    #     assert response.status_code == status.HTTP_403_FORBIDDEN
    #     assert post_resp.data['open_date'] != '2025-12-15'
    #     assert post_resp.data['open_date'] == '2024-04-15'

    # def test_if_partial_permission_user_cannot_delete_applicationdate_return_403(self, post, delete, group_instance):
    #     post_resp = post(APPLICANT_ENDPOINT,
    #                      self.applicationdate_payload())
    #     excluded_permission = Permission.objects.filter(
    #         name__in=['Can delete application date'])
    #     group_instance.permissions.remove(*excluded_permission)
    #     response = delete(APPLICANT_ENDPOINT, post_resp.data['id'])

    #     assert response.status_code == status.HTTP_403_FORBIDDEN
    #     assert post_resp.data['id'] > 0

    # def test_if_permissionless_user_cannot_post_applicationdate_return_403(self, post, group_instance):
    #     """
    #     Because they cannot post means they can't get, update or delete the resource.
    #     """
    #     excluded_permission = Permission.objects.filter(
    #         name__in=['Can add application date'])
    #     group_instance.permissions.remove(*excluded_permission)

    #     data = self.applicationdate_payload()
    #     response = post(APPLICANT_ENDPOINT, data)

    #     assert response.status_code == status.HTTP_403_FORBIDDEN

    def test_if_data_is_invalid_return_400(self, post, api_client):
        """ Although this test will fail if the data is valid; however,
            instead of returning 'assert 201 == 400' error, it will 
            return a misleading error message about ApplicationDate.
        """
        data = {
            'religion': '',
            'image': create_image_file(),
            'gender': 'Male',
            'birth_date': '2004-03-23',
            'county': 'Bong'
        }

        post(USERS_ENDPOINT, user_payload())
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        response = post(APPLICANT_ENDPOINT, data)

        assert response.status_code == status.HTTP_400_BAD_REQUEST

# from io import BytesIO
# from reportlab.lib.pagesizes import letter
# from reportlab.pdfgen import canvas


def create_pdf_file():
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    c.drawString(100, 750, "Hello, this is a test PDF file!")
    c.save()
    buffer.seek(0)
    return buffer


@pytest.mark.django_db
class TestApplicantDocument:
    """ 
    If you don't want field validation use Model Baker else add the fields manually.
    baker.make(User, email='mecom') Baker considers the email as valid.
    """

    def applicant_payload(self):
        """ Country default is Liberia so it's not included."""
        return {
            'institution': 'Doriam University',
            'major': 'Math',
            'Manor': 'Physics',
            'graduation_year': 2020,
            'qualification': 'Bachelor',
            'county': 'Bong',
            'cgpa': 3.8,
            'applicant_id': 11,
            'degree': create_pdf_file(),
            'police_clearance': create_pdf_file(),
            'resume': create_pdf_file(),
            'community_letter': create_pdf_file(),
            'reference_letter': create_pdf_file(),
            'application_letter': create_pdf_file(),
        }

    def test_if_authenticated_user_can_post_applicant_return_201(self, get, api_client):
        """ See this class for the comment"""
        from core.models import User
        user = baker.make(User, email='mecom')
        api_client.credentials(HTTP_AUTHORIZATION=JWT + USER_TOKEN)
        user_resp = api_client.get(f'/core/users/{user.id}/')

        applicant = baker.make(Applicant)
        response = get(APPLICANT_ENDPOINT, applicant.user.id)
        # instance = Applicant.objects.get(user_id=user_resp.data['id'])
        print("********************", user)
        assert response.status_code == status.HTTP_200_OK
        assert user.id > 0
        assert user_resp.data['email'] == 'mecom'
